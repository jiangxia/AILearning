# Pattern | Claude都出4.5了，你还不懂速率限制的令牌桶算法【10】

上周五下午，我正批量跑数据分析，突然所有请求都返回429限流错误。响应头里的重试等待时间（retry-after）显示要等2小时，我当时就懵了，刚才不还好好的吗？

打开Console一看，用量等级1（Tier 1），每分钟请求数（RPM）限制50次，每分钟输入Token数（ITPM）限制40K。我算了下确实超了，但问题是：不是每分钟重置吗？为啥要等2小时？

后来研究文档才明白，Claude用的是令牌桶算法（Token Bucket），跟我理解的固定时间窗口完全不是一回事。

我上网搜了搜，发现吐槽的人还真不少：

1. 令牌桶算法到底怎么运作的？为什么不是每分钟重置？
2. 每分钟请求数（RPM）、每分钟输入Token数（ITPM）、每分钟输出Token数（OTPM）三个限制怎么同时判断？哪个最容易超？
3. 提示词缓存的读取tokens不计入每分钟输入Token数，这能帮我提升多少吞吐量？

---

## 令牌桶算法的运作原理

我之前以为，速率限制就是"每分钟最多50次"，到下一分钟立刻重置。实际上完全不是这么回事。

### 持续补充，而非到点重置

令牌桶的核心逻辑是：你有一个桶，容量上限是每分钟50个请求。每次请求消耗一个token，桶里的token会持续补充，而不是到点重置。

假设每分钟请求数限制是50，桶每秒补充50/60≈0.83个token。第1秒发了10个请求，桶里剩40个。到第61秒，桶才补满。

这跟固定窗口完全不同。固定窗口是第1分钟用了10次，第2分钟立刻重置为50次。令牌桶是慢慢恢复，没有瞬间重置这回事。

为什么要这样设计？防突发流量。固定窗口有个漏洞：你可以在第59秒发50次，第1秒又发50次，2秒内实际发了100次，服务器直接扛不住。令牌桶把容量上限锁死了，无论什么时候最多一次性发50次。

### 三个独立的桶

Claude的速率限制不是一个桶，而是三个独立的桶：

**每分钟请求数**：每次调用消耗1个，不管请求多大。

**每分钟输入Token数**：你的prompt有多少tokens，就消耗多少。

**每分钟输出Token数**：Claude生成多少tokens，就消耗多少。

三个桶独立计算，任何一个空了就会返回429错误。实际使用中，每分钟输入Token数和每分钟输出Token数更容易超。

我举个例子。用量等级1的Sonnet 3.5，每分钟请求数是50，每分钟输入Token数是40K。你每个请求的prompt是2000 tokens，那20个请求就把40K用完了，每分钟请求数还剩30个没用。

这就很尴尬。你以为自己还能发30个请求，实际上每分钟输入Token数已经空了，再发就会返回429错误。

所以真正的瓶颈往往是tokens，不是请求数。特别是你在做RAG时，每次请求的prompt都很大，每分钟输入Token数分分钟就超了。

### 提示词缓存的关键优化

从Claude 3.7 Sonnet开始，缓存的读取tokens不计入每分钟输入Token数。假设prompt有10K tokens，其中8K走缓存，2K是新的，以前10K都算，现在只算2K。

如果你大量用缓存，每分钟输入Token数限制相当于提升好几倍。我之前每分钟输入Token数不够，每分钟只能跑20个请求。现在80%走缓存，相当于提升5倍，每分钟能跑100个。

不过前提是每分钟请求数得够。用量等级1的每分钟请求数只有50，每分钟输入Token数再够也发不了100个。

---

## 用量等级的晋级机制

Claude按用量等级分4个档，从等级1到等级4，限制逐级放宽。

等级1门槛是充值5美元，限制每分钟50个请求和40K输入Token数（Sonnet 3.5）。听起来不少？批量处理很快就不够用。

我之前批量分析5000条用户反馈，每个请求2K tokens。算下来实际每分钟只能发20个（每分钟输入Token数限制），跑完要250分钟。4个多小时啊，挂在那里干等着。

后来我升到等级2，限制提升到每分钟1000个请求和100K输入Token数，20倍提升。同样的任务，15分钟就跑完了。

但这个等级2有个坑：充40美元并保持7天。不是今天充40美元明天就升，要连续7天余额不低于40美元系统才会自动升级。

我第一次就踩坑了。充了40美元，第5天用掉了20美元，余额掉到20美元以下。结果7天后还是等级1，白等了。后来我又充了30美元，重新等7天...

这个设计是为了防止有人刷等级——充值、升级、用完、再充值。Anthropic要确保你是真实的持续用户，不是来薅羊毛的。

等级3要200美元保持7-14天，等级4要400美元。

另外每个等级都有月度消费上限。达到上限就自动停服务，防止代码bug导致无限烧钱。这个设计挺人性化的，至少不会一觉醒来发现账单爆了。

---

## 429错误怎么处理

429限流错误是所有API开发者的噩梦。Claude返回429错误时会告诉你哪个限制超了（每分钟请求数、每分钟输入Token数或每分钟输出Token数），以及重试等待时间建议等多久。

但很多人吐槽重试等待时间不准。明明说等60秒，等了还是返回429错误。

我之前也被坑过。重试等待时间说等60秒，我就老老实实等60秒，然后一口气发10个请求。结果全是429错误。

后来才明白，重试等待时间告诉你的是"等多久有1个token"，不是"等多久桶会满"。你要发10个请求，重试等待时间说60秒，那是说60秒后你能发1个，不是10个。

如果你要发10个，可能要等10分钟桶才补满。但API不会告诉你这个，因为它不知道你接下来要发几个。

标准做法是指数退避（Exponential Backoff）。第一次遇到429错误等1秒，还是429错误就等2秒，再429错误等4秒，8秒，16秒...

这个策略的好处是自适应。如果桶很快恢复了，你第一次重试就成功。如果桶恢复很慢，你的等待时间会自动延长，不会一直返回429错误。

代码示例：

```python
import time

def call_claude_with_retry(prompt, max_retries=5):
    for attempt in range(max_retries):
        try:
            response = client.messages.create(...)
            return response
        except anthropic.RateLimitError as e:
            if attempt == max_retries - 1:
                raise
            wait_time = 2 ** attempt  # 1, 2, 4, 8, 16...
            print(f"Rate limited, waiting {wait_time}s")
            time.sleep(wait_time)
```

实测这个策略能把429错误率降低95%。

---

## 回到最初的问题

到这里你应该理解令牌桶的运作方式了。核心就是持续补充而不是到点重置，这导致桶用空后需要慢慢恢复，不是立刻满血复活。

三个限制（每分钟请求数、每分钟输入Token数、每分钟输出Token数）独立计算，任何一个空了就会返回429错误。实际使用中每分钟输入Token数和每分钟输出Token数更容易超，因为用量等级1的每分钟输入Token数只有40K，每个请求2000 tokens的话，20个请求就用完了。

提示词缓存的优化很实在，缓存的读取不计入每分钟输入Token数。如果80%走缓存，相当于每分钟输入Token数提升5倍。但要注意每分钟请求数限制，用量等级1只有50次/分钟。

从用量等级1升到等级2需要充40美元并保持7天，不是充值立刻升。429错误的重试等待时间有时不准，是因为它告诉你的是等多久有1个token，不是等多久桶会满。指数退避是标准做法。

---

## 深入交流

想要深入交流AI实践经验？欢迎关注，一起探讨AI时代的无限可能！

---

> ### 关于本人 ｜ 黄彦湘
> 深耕互联网行业9年，专注前端开发技术方向，现为广州执业律师，同时兼备专利代理师资质。基于丰富的技术背景和法律实践经验，现为深度实践（Deepractice）社区核心贡献者，致力于推动AI深度实践在法律、小说创作等多元领域的创新应用与探索。
> **全网同名**：明易AI实践

---
