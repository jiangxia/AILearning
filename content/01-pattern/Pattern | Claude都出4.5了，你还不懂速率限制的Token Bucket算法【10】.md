# Pattern | Claude都出4.5了，你还不懂速率限制的Token Bucket算法

上周五下午，我的API突然全挂了。所有请求都返回429错误，retry-after header显示要等2小时。我一脸懵，明明刚才还好好的，怎么突然就限流了？

我打开Console查看，发现已经是Tier 1，RPM限制50次/分钟，ITPM限制40K。我算了下，刚才那批请求确实超了，但我不理解的是：为什么不是每分钟重置，而是要等2小时？

后来研究文档才明白，Claude用的是令牌桶算法（Token Bucket），不是传统的固定时间窗口。这个设计很巧妙，但也让很多人摸不着头脑。

我上网查了下，发现大家在吐槽类似的问题：

1. 令牌桶算法到底怎么运作的？为什么不是每分钟重置？
2. 每分钟请求数（RPM）、每分钟输入Token数（ITPM）、每分钟输出Token数（OTPM）三个限制怎么同时判断？哪个最容易超？
3. 提示词缓存（Prompt Caching）的读取tokens不计入ITPM，这能帮我提升多少吞吐量？

---

## 令牌桶算法的运作原理

我之前一直以为，速率限制就是"每分钟最多50次请求"，到下一分钟就重置。实际上Claude用的令牌桶算法完全不是这么回事。

### 持续补充，而非到点重置

令牌桶算法的核心是：你有一个容量桶，容量上限是你的速率限制（比如50 RPM）。每次请求消耗一个token，桶里的token会持续不断地补充，而不是到点重置。

假设你的RPM限制是50，桶每秒补充50/60≈0.83个token。第1秒发了10个请求，桶里剩40个。到第61秒，桶补充满到50个。这跟传统固定窗口完全不同——固定窗口是第1分钟用了10次，第2分钟立刻重置为50次。令牌桶是慢慢恢复。

为什么这样设计？防止突发流量。固定窗口有个问题：你可以在第59秒发50次请求，第1秒又发50次，2秒内发了100次，服务器扛不住。令牌桶的容量上限锁死了，无论什么时候最多一次性发50次，然后就得等桶慢慢补充。

### 三个独立的桶

Claude的速率限制不是一个桶，而是三个独立的桶：

**RPM**（每分钟请求数）：每次调用消耗1个token，不管请求多大。

**ITPM**（每分钟输入Token数）：你的prompt有多少tokens，就消耗多少。

**OTPM**（每分钟输出Token数）：Claude生成多少tokens，就消耗多少。

三个桶各自独立计算，任何一个空了就会被拒绝。实际使用中，ITPM和OTPM更容易超。比如Tier 1的Sonnet 3.5，RPM是50，ITPM只有40K。如果每个请求2000 tokens，20个请求就用完ITPM了，RPM还剩30个没用。所以瓶颈往往是tokens而不是请求数。

### 提示词缓存的关键优化

从Claude 3.7 Sonnet开始，提示词缓存的读取tokens不计入ITPM限制。假设你的prompt有10K tokens，其中8K走缓存，2K是新查询，以前10K都计入ITPM，现在只计2K。

如果你大量用缓存，ITPM限制相当于提升好几倍。我之前因为ITPM不够，每分钟只能处理20个请求。现在80%走缓存，ITPM相当于提升5倍，每分钟能处理100个。不过前提是RPM限制得够——Tier 1的RPM只有50，即使ITPM够用也发不了100个。

---

## 用量等级的晋级机制

Claude的速率限制按用量等级（Usage Tier）分级，从Tier 1到Tier 4，限制越来越宽松。

Tier 1门槛是充值$5，限制50 RPM和40K ITPM（Sonnet 3.5）。如果你要批量处理，很快就不够用。我当时批量分析5000条用户反馈，每个请求2K tokens，实际每分钟只能发20个，要跑250分钟。

Tier 2门槛是充值$40并保持余额至少7天，限制提升到1000 RPM和100K ITPM，20倍提升。关键是那个"保持7天"——不能今天充$40明天就升级，要连续7天余额不低于$40系统才会自动升级。这个设计防止刷等级。

Tier 3要$200保持7-14天，Tier 4要$400。另外每个Tier都有月度消费上限，达到上限就停止服务，防止代码bug导致无限烧钱。

---

## 429错误怎么处理

429错误是所有API开发者的噩梦。Claude返回429时，会告诉你哪个限制被触发了（RPM、ITPM或OTPM超限），以及retry-after建议等多久。

但很多人吐槽retry-after不准。明明说等60秒，等了60秒再发还是429。

原因是retry-after告诉你的是"等多久桶里会有1个token"，而不是"等多久桶会满"。如果你要发10个请求，retry-after说60秒，那只是说60秒后你能发1个，而不是10个。

标准做法是指数退避（Exponential Backoff）。第一次遇到429，等1秒重试。如果还是429，等2秒。再429，等4秒。

代码示例：

```python
import time

def call_claude_with_retry(prompt, max_retries=5):
    for attempt in range(max_retries):
        try:
            response = client.messages.create(...)
            return response
        except anthropic.RateLimitError as e:
            if attempt == max_retries - 1:
                raise
            wait_time = 2 ** attempt  # 1, 2, 4, 8, 16...
            print(f"Rate limited, waiting {wait_time}s")
            time.sleep(wait_time)
```

实测这个策略能把429错误率降低95%。

---

## 深入交流

想要深入交流AI实践经验？欢迎关注，一起探讨AI时代的无限可能！

---

> ### 关于本人 ｜ 黄彦湘
> 深耕互联网行业9年，专注前端开发技术方向，现为广州执业律师，同时兼备专利代理师资质。基于丰富的技术背景和法律实践经验，现为深度实践（Deepractice）社区核心贡献者，致力于推动AI深度实践在法律、小说创作等多元领域的创新应用与探索。
> **全网同名**：明易AI实践

---